#!/bin/bash


function unimplemented()
{
    echo "UNIMPLEMENTED"
    exit 127
}


function 1p_op()
{
    cmd="$1"
    shift
    op $cmd --session="$token_auth" "$@"
}


function setup_initial()
{
    echo "Hello! Before we start, I need a few parameters from you. You can look them up"
    echo "in the browser or desktop version of 1Password, typically somewhere around the"
    echo "Preferences dialog."
    echo
    read -p "Domain name: " domain && \
        read -p "E-mail address: " email && \
        read -p "Secret key: " secret_key
    cat > $path_config <<-CONFIG
	{
	    "domain": "$domain",
	    "email": "$email",
	    "secret_key": "$secret_key",
	    "token_auth": ""
	}
	CONFIG
    token_auth=""
    echo "Persistent configuration saved."
}


function set_token_auth()
{
    token_auth="$1"
    local p=$(mktemp)
    jq ".token_auth = \"$token_auth\"" $path_config >$p
    mv $p $path_config
}


function ensure_login()
{
    local msg_error=$(1p_op "get item" __dummy__ 2>&1)
    if grep --quiet 'not currently signed in\|Authentication required' <<<"$msg_error" && [ "$action" != "logout" ]; then
        local p=$(mktemp)
        op signin --output=raw $domain $email $secret_key >$p && \
            set_token_auth $(< $p)
        local x=$?
        rm -f $p
        [ "$x" -ne 0 ] && exit $x
    fi
}


function unquote()
{
    echo "$1" | xargs
}


function make_map_vaults()
{
    local p=$(mktemp)
    1p_op "list vaults" | jq --compact-output 'map({"key": .uuid, "value": .name}) | from_entries' >$p && \
        map_vaults=$(< $p)
    local x=$?
    rm -f $p
    [ "$x" -ne 0 ] && exit $x
}


function list_items()
{
    make_map_vaults
    local p=$(mktemp)
    1p_op "list items" | \
        jq --compact-output --argjson map_vaults "$map_vaults" \
            'map(
                {
                    "uuid"    : .uuid,
                    "vault"   : $map_vaults[.vaultUuid],
                    "name"    : .overview.title
                }
            )' >$p
    local x=$?
    local list_reformatted=$(<$p)
    rm -f $p
    [ "$x" -ne 0 ] && exit $x

    if [ "$format" = "json" ]; then
        jq '.' <<<"$list_reformatted"
    else
        local len_uuid=$(jq 'map(.uuid | length) | max' <<<"$list_reformatted")
        local len_vault=$(jq 'map(.vault | length) | max' <<<"$list_reformatted")
        jq --raw-output 'sort_by([.vault, .name]) | .[] | [.uuid, .vault, .name] | join("::")' <<<"$list_reformatted" | \
            awk -F '::' "\
                BEGIN{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \"UUID\", \"VAULT\", \"NAME\") } \
                1{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \$1, \$2, \$3) }"
    fi
}


function build_opt_vault()
{
    local opt_vault=""
    if [ -n "$vault" ]; then
        opt_vault="--vault=$vault"
    fi
}


function get_item_from_1p()
{
    build_opt_vault
    local p=$(mktemp)
    trap "rm -f $p" EXIT
    1p_op "get item" "$title" $opt_vault >$p
    x=$?
    if [ $x -eq 0 ]; then
        jq --compact-output --argjson map_vaults "$map_vaults" '
            def field_value(name_field): ((.details.fields // [])[] | select(.name == name_field) | .value) // "" ;
            {
                "uuid":        .uuid,
                "username":    field_value("username"),
                "password":    field_value("password"),
                "notes":       (.details.notesPlain // ""),
                "title":       (.overview.title // ""),
                "url":         (.overview.url // ""),
                "vault":       ($map_vaults[.vaultUuid] // .vaultUuid),
                "details_raw": .details
            }' <$p
    else
        return $x
    fi
}


function get_item_from_1p_or_create()
{
    if ! get_item_from_1p 2>/dev/null; then
        cat <<-SKELETON
		{
		    "uuid":        "",
		    "username":    "",
		    "password":    "",
		    "notes":       "",
		    "title":       "$title",
		    "url":         "",
		    "vault":       "$vault",
		    "details_raw": $(1p_op "get template" Login)
		}
		SKELETON
    fi
}


function get_item()
{
    make_map_vaults
    get_item_from_1p | \
        (
            if [ "$format" = "json" ]; then
                jq 'del(.details_raw)'
            else
                jq --raw-output --arg item "$item" '.[$item]' | (
                    if [ "$is_copy_or_echo" = "echo" ]; then
                        cat
                    else
                        tr -d "\n" | xsel -ib
                    fi
                )
            fi
        ) || exit $?
}


function modify_item()
{
    build_opt_vault
    if 1p_op "create item" Login $(echo "$details" | op encode) --title="$title" --url="$url" $opt_vault >/dev/null; then
        if [ -n "$uuid_orig" ]; then
            1p_op "delete item" "$uuid_orig"
        fi
    fi
}


function set_item()
{
    map_vaults='{}'
    local p=$(mktemp)
    get_item_from_1p_or_create >$p || exit $?
    trap "rm -f $p" EXIT
    local item_raw=$(cat $p && rm $p)
    uuid_orig=$(jq --raw-output '.uuid' <<<"$item_raw")
    url=$(jq --raw-output '.url' <<<"$item_raw")
    title=$(jq --raw-output '.title' <<<"$item_raw")
    vault=$(jq --raw-output '.vault' <<<"$item_raw")
    details=$(jq --raw-output '.details_raw' <<<"$item_raw")

    local new_value="${params[1]}"
    case "$item" in
        password | username)
            details=$(jq --arg attr "$item" --arg new_value "$new_value" \
                --argjson map_type '{"username": "T", "password": "P"}' \
                '.fields = ([.fields[] | select(.name != $attr)] + [{"name": $attr, "designation": $attr, "type": $map_type[$attr], "value": $new_value}])' \
                <<<"$details")
            ;;
        notes)
            details=$(jq --arg new_value "$new_value" '.notesPlain = $new_value' <<<"$details")
            ;;
        url | title)
            eval "$item=\"$new_value\""
            ;;
        *)
            echo "Don't know how to set attribute \`$item'."
            exit 10
            ;;
    esac

    modify_item
}


function split_title_vault()
{
    if [ -n "${params[0]}" ]; then
        eval $(jq --raw-input --raw-output 'split("@") | "title=\"\(.[0])\"\nvault=\"\(.[1] // "")\"\n"' <<<"${params[0]}")
    else
        title=""
        vault=""
    fi
}


function do_default()
{
    split_title_vault
    ensure_login

    case "$num_params" in
        0) list_items ;;
        1) get_item   ;;
        *) set_item   ;;
    esac
}


function do_edit()
{
    ensure_login
    split_title_vault
    map_vaults='{}'
    if [ -n "title" ]; then
        if [ -z "$EDITOR" ]; then
            EDITOR="vi"
        fi

        local p=$(mktemp)
        trap "rm -f $p $p.raw" EXIT
        get_item_from_1p_or_create >"$p.raw" || exit $?
        jq --raw-output '.notes' "$p.raw" >"$p"
        eval "$EDITOR $p" || exit $?

        if ! diff -q $p <(jq --raw-output '.notes' "$p.raw") 2>/dev/null; then
            uuid_orig=$(jq --raw-output '.uuid' "$p.raw")
            url=$(jq --raw-output '.url' "$p.raw")
            vault=$(jq --raw-output '.vault' "$p.raw")
            details=$(jq --raw-output --arg notes "$(cat "$p")" '.details_raw | .notesPlain = $notes' "$p.raw")
            modify_item
        fi
    else
        echo "Missing name of item to edit notes for."
        exit 20
    fi
}


function do_rm()
{
    ensure_login
    split_title_vault
    if [ -n "$title" ]; then
        build_opt_vault
        local p=$(mktemp)
        trap "rm -f $p" EXIT
        if ! 1p_op "delete item" "$title" $opt_vault 2>$p; then
            # 1Password's op is stupid: it confounds trashed and non-trashed
            # items when trying to delete. Since we are forced to
            # create+delete in order to modify an item, we obviously become
            # stuck with a large set of identically-named items, making the
            # first delete fail unduly often. Fortunately, this first delete
            # shows us the UUIDs of colliding objects, so we can delete all of
            # them thereafter. Emptying the trash, either through the browser
            # or the desktop app, finally removes all these spurious dupes
            # from the database altogether.
            for uuid in $(jq --raw-input --raw-output 'match("op delete item ([0-9a-z]+)").captures[0].string' $p); do
                1p_op "delete item" "$uuid"
            done
        fi
    else
        echo "Missing name of item to remove."
        exit 20
    fi
}


function do_logout()
{
    1p_op "signout" >/dev/null 2>&1
    set_token_auth ""
    exit 0
}


num_params=""
declare -a params
is_setup_initial=""
action="default"
format=""
item="password"
is_copy_or_echo="copy"

eval set -- $(getopt --name "$0" --options 'CETUehjnpu0' --longoptions 'copy,echo,title,url,edit,help,json,notes,password,raw,rm,setup,user,logout:' -- "$@") || exit $?
while [ -n "$1" ]; do
    case "$1" in
        # -h | --help)
        #     action="doc"
        #     ;;
        -C | --copy)
            is_copy_or_echo="copy"
            ;;
        -E | --echo)
            is_copy_or_echo="echo"
            ;;
        -T | --title)
            item="title"
            ;;
        -U | --url)
            item="url"
            ;;
        -e | --edit)
            action="edit"
            ;;
        -j | --json)
            format="json"
            ;;
        -n | --notes)
            item="notes"
            ;;
        -p | --password)
            item="password"
            ;;
        --raw)
            format="raw"
            ;;
        --rm)
            action="rm"
            ;;
        --setup)
            is_setup_initial="yes"
            ;;
        -u | --user)
            item="username"
            ;;
        -0 | --logout)
            action="logout"
            ;;
        --)
            num_params=0
            ;;
        *)
            if [ -z "$num_params" ]; then
                echo "Unknown parameter: $1"
                echo "Check out documentation by invoking $0 --help."
                exit 1
            else
                params[$((num_params++))]=$(unquote "$1")
            fi
    esac
    shift
done

path_config="$HOME/.1p"
declare -a config
if [ ! -f "$path_config" -o -n "$is_setup_initial" ]; then
    setup_initial
else
    for name_config in domain email secret_key token_auth; do
        value=$(jq --raw-output ".$name_config" $path_config)
        eval "$name_config='$value'"
    done
fi

eval "do_$action"
exit $?
