#!/bin/bash


function unimplemented()
{
    echo "UNIMPLEMENTED"
    exit 127
}


function 1p_op()
{
    cmd="$1"
    shift
    op $cmd --session="$token_auth" "$@"
}


function setup_initial()
{
    echo "Hello! Before we start, I need a few parameters from you. You can look them up"
    echo "in the browser or desktop version of 1Password, typically somewhere around the"
    echo "Preferences dialog."
    echo
    read -p "Domain name: " domain && \
        read -p "E-mail address: " email && \
        read -p "Secret key: " secret_key
    cat > $path_config <<-CONFIG
	{
	    "domain": "$domain",
	    "email": "$email",
	    "secret_key": "$secret_key",
	    "token_auth": ""
	}
	CONFIG
    chmod 600 $path_config
    token_auth=""
    echo "Persistent configuration saved."
}


function set_token_auth()
{
    token_auth="$1"
    local p=$(mktemp)
    jq ".token_auth = \"$token_auth\"" $path_config >$p
    mv $p $path_config
}


function ensure_login()
{
    local msg_error=$(1p_op "get item" __dummy__ 2>&1)
    if grep --quiet 'not currently signed in\|Authentication required' <<<"$msg_error" && [ "$action" != "logout" ]; then
        local p=$(mktemp)
        op signin --output=raw $domain $email $secret_key >$p && \
            set_token_auth $(< $p)
        local x=$?
        rm -f $p
        [ "$x" -ne 0 ] && exit $x
    fi
}


function unquote()
{
    echo "$1" | xargs
}


function make_map_vaults()
{
    local p=$(mktemp)
    1p_op "list vaults" | jq --compact-output 'map({"key": .uuid, "value": .name}) | from_entries' >$p && \
        map_vaults=$(< $p)
    local x=$?
    rm -f $p
    [ "$x" -ne 0 ] && exit $x
}


function list_items()
{
    make_map_vaults
    local p=$(mktemp)
    1p_op "list items" | \
        jq --compact-output --argjson map_vaults "$map_vaults" \
            'map(
                {
                    "uuid"    : .uuid,
                    "vault"   : $map_vaults[.vaultUuid],
                    "name"    : .overview.title
                }
            )' >$p
    local x=$?
    local list_reformatted=$(<$p)
    rm -f $p
    [ "$x" -ne 0 ] && exit $x

    if [ "$format" = "json" ]; then
        jq '.' <<<"$list_reformatted"
    else
        local len_uuid=$(jq 'map(.uuid | length) | max' <<<"$list_reformatted")
        local len_vault=$(jq 'map(.vault | length) | max' <<<"$list_reformatted")
        jq --raw-output 'sort_by([.vault, .name]) | .[] | [.uuid, .vault, .name] | join("::")' <<<"$list_reformatted" | \
            awk -F '::' "\
                BEGIN{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \"UUID\", \"VAULT\", \"NAME\") } \
                1{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \$1, \$2, \$3) }"
    fi
}


function build_opt_vault()
{
    local opt_vault=""
    if [ -n "$vault" ]; then
        opt_vault="--vault=$vault"
    fi
}


function get_item_from_1p()
{
    build_opt_vault
    local p=$(mktemp)
    trap "rm -f $p" EXIT
    1p_op "get item" "$title" $opt_vault >$p
    x=$?
    if [ $x -eq 0 ]; then
        jq --compact-output --argjson map_vaults "$map_vaults" '
            def field_value(name_field): ((.details.fields // [])[] | select(.name == name_field) | .value) // "" ;
            {
                "uuid":        .uuid,
                "username":    field_value("username"),
                "password":    field_value("password"),
                "notes":       (.details.notesPlain // ""),
                "title":       (.overview.title // ""),
                "url":         (.overview.url // ""),
                "vault":       ($map_vaults[.vaultUuid] // .vaultUuid),
                "details_raw": .details
            }' <$p
    else
        return $x
    fi
}


function get_item_from_1p_or_create()
{
    if ! get_item_from_1p 2>/dev/null; then
        cat <<-SKELETON
		{
		    "uuid":        "",
		    "username":    "",
		    "password":    "",
		    "notes":       "",
		    "title":       "$title",
		    "url":         "",
		    "vault":       "$vault",
		    "details_raw": $(1p_op "get template" Login)
		}
		SKELETON
    fi
}


function get_item()
{
    make_map_vaults
    get_item_from_1p | \
        (
            if [ "$format" = "json" ]; then
                jq 'del(.details_raw)'
            else
                jq --raw-output --arg item "$item" '.[$item]' | (
                    if [ "$is_copy_or_echo" = "echo" ]; then
                        cat
                    else
                        tr -d "\n" | xsel -ib
                    fi
                )
            fi
        ) || exit $?
}


function modify_item()
{
    build_opt_vault
    if 1p_op "create item" Login $(echo "$details" | op encode) --title="$title" --url="$url" $opt_vault >/dev/null; then
        if [ -n "$uuid_orig" ]; then
            1p_op "delete item" "$uuid_orig"
        fi
    fi
}


function set_item()
{
    map_vaults='{}'
    local p=$(mktemp)
    get_item_from_1p_or_create >$p || exit $?
    trap "rm -f $p" EXIT
    local item_raw=$(cat $p && rm $p)
    uuid_orig=$(jq --raw-output '.uuid' <<<"$item_raw")
    url=$(jq --raw-output '.url' <<<"$item_raw")
    title=$(jq --raw-output '.title' <<<"$item_raw")
    vault=$(jq --raw-output '.vault' <<<"$item_raw")
    details=$(jq --raw-output '.details_raw' <<<"$item_raw")

    local new_value="${params[1]}"
    case "$item" in
        password | username)
            details=$(jq --arg attr "$item" --arg new_value "$new_value" \
                --argjson map_type '{"username": "T", "password": "P"}' \
                '.fields = ([.fields[] | select(.name != $attr)] + [{"name": $attr, "designation": $attr, "type": $map_type[$attr], "value": $new_value}])' \
                <<<"$details")
            ;;
        notes)
            details=$(jq --arg new_value "$new_value" '.notesPlain = $new_value' <<<"$details")
            ;;
        url | title)
            eval "$item=\"$new_value\""
            ;;
        *)
            echo "Don't know how to set attribute \`$item'."
            exit 10
            ;;
    esac

    modify_item
}


function split_title_vault()
{
    if [ -n "${params[0]}" ]; then
        eval $(jq --raw-input --raw-output 'split("@") | "title=\"\(.[0])\"\nvault=\"\(.[1] // "")\"\n"' <<<"${params[0]}")
    else
        title=""
        vault=""
    fi
}


function do_default()
{
    split_title_vault
    ensure_login

    case "$num_params" in
        0) list_items ;;
        1) get_item   ;;
        *) set_item   ;;
    esac
}


function do_edit()
{
    ensure_login
    split_title_vault
    map_vaults='{}'
    if [ -n "title" ]; then
        if [ -z "$EDITOR" ]; then
            EDITOR="vi"
        fi

        local p=$(mktemp)
        trap "rm -f $p $p.raw" EXIT
        get_item_from_1p_or_create >"$p.raw" || exit $?
        jq --raw-output '.notes' "$p.raw" >"$p"
        eval "$EDITOR $p" || exit $?

        if ! diff -q $p <(jq --raw-output '.notes' "$p.raw") 2>/dev/null; then
            uuid_orig=$(jq --raw-output '.uuid' "$p.raw")
            url=$(jq --raw-output '.url' "$p.raw")
            vault=$(jq --raw-output '.vault' "$p.raw")
            details=$(jq --raw-output --arg notes "$(cat "$p")" '.details_raw | .notesPlain = $notes' "$p.raw")
            modify_item
        fi
    else
        echo "Missing name of item to edit notes for."
        exit 20
    fi
}


function count_chars()
{
    tr -d "\n" <<<"$1" | jq --raw-input "explode | map(select($2)) | implode | length"
}


function count_uppers()
{
    count_chars "$1" '. >= 64 and . <= 90'
}


function count_digits()
{
    count_chars "$1" '. >= 48 and . <= 57'
}


function count_symbols()
{
    count_chars "$1" '[.] | inside("_-+=!@#$%&*()[]{}\\|;:,.<>/?~" | explode)'
}


function string_length()
{
    jq --raw-input 'length' <<<"$1"
}


function do_generate()
{
    if [ -z "${params[0]}" ]; then
        echo "Specify the name of the item for which to generate a random password."
        exit 41
    fi

    eval $(
        jq --raw-output 'split(":") | map(try tonumber catch null) |
            "length_total=\(.[0] // 16); num_uppers=\(.[1] // 1); num_digits=\(.[2] // 1); num_symbols=\(.[3] // 1)"' \
            <<<"\"$reqs\""
    ) || exit $?
    local max_length=40
    local min_length=8
    local min_all_lower=16
    if [ "$length_total" -gt "$max_length" ]; then
        cat 2>/dev/null <<TOOLONG
$length_total characters? Take a chill pill, buddy, and stick to $max_length or
less. You know you might have to *type* this password sometimes, yes?
Seriously. I'm setting you back at $max_length characters.
TOOLONG
        length_total=$max_length
    elif [ $length_total -lt 8 ]; then
        cat 2>/dev/null <<TOOSHORT
$length_total characters. Come on, buddy. This is a computer, and this is the
goddamn 21st century. In the overwhelming majority of cases, you will merely
have to copy-paste this damn password. Geez, you people. I'm setting you up to
$min_length characters, and I don't care whether you like it.
TOOSHORT
        length_total=$min_length
    fi

    length_nonlower=$(( $num_uppers + $num_digits + $num_symbols ))
    if [ $length_nonlower -gt $length_total ]; then
        cat 2>/dev/null <<IMPOSSIBLE
Sigh -- apparently, math is hard. You want a password with $num_uppers uppercase
letters, $num_digits digits and $num_symbols symbols, but composed of no more
than $length_total characters. Do the math: it's impossible. I will thus
generate a longer password, $length_nonlower charcters long, in order to
satisfy the former constraints.
IMPOSSIBLE
        $length_total=$length_nonlower
    fi

    if [ $num_uppers -lt 1 -a $num_digits -lt 1 -a $num_symbols -lt 1 -a $length_total -lt 16 ]; then
        cat 2>/dev/null <<JUSTBAD
You know, I've seen the XKCD cartoon and I know of the common password best
practices, but you're taking this too far. Either you go long, or you go
complex. I think that complex sucks, so I'm rising your password length to
$min_all_lower characters. Don't thank me, I'm just a machine.
JUSTBAD
        length_total=$min_all_lower
    fi

    if [ $num_uppers -lt 0 ]; then
        num_uppers=0
    fi
    if [ $num_digits -lt 0 ]; then
        num_digits=0
    fi
    if [ $num_symbols -lt 0 ]; then
        num_symbols=0
    fi

    local presuf="$prefix$suffix"
    local length_middle=$(( $length_total - $(string_length "$presuf") ))
    if [ $length_middle -le 0 ]; then
        if [ $(count_uppers "$presuf") -lt $num_uppers -o \
            $(count_digits "$presuf") -lt $num_digits -o \
            $(count_symbols "$presuf") -lt $num_symbols ]
        then
            cat 2>/dev/null <<INCOHERENT
Your prefix and suffix make up a password at least as long as you wish for,
but without all the uppercase letters, digits or symbols you demand.  Get your
act together and try again, buddy.
INCOHERENT
            exit 42
        else
            cat 2>/dev/null <<PRESUF
Warning: the provided prefix and suffix suffice to satisfy all the constraints
set on the final password, so it will bear no randomly generated component.
PRESUF
            password="$presuf"
        fi
    else
        while true; do
            local middle=$(head -c $length_middle /dev/urandom | \
                tr '\000-\377' 'a-za-za-za-zA-ZA-ZA-Z0-90-90-9_+=!@#$%&*()[]{}|;:,.<>?~_+=!@#$%&*()[]{}|')
            password="$prefix$middle$suffix"
            if [ $(count_uppers "$password") -ge $num_uppers -a \
                $(count_digits "$password") -ge $num_digits -a \
                $(count_symbols "$password") -ge $num_symbols ]
            then
                break
            fi
        done
    fi

    echo "-- $password --" && exit 0
    exec $0 --password "${params[0]}" "$password"
}


function do_rm()
{
    ensure_login
    split_title_vault
    if [ -n "$title" ]; then
        build_opt_vault
        local p=$(mktemp)
        trap "rm -f $p" EXIT
        if ! 1p_op "delete item" "$title" $opt_vault 2>$p; then
            # 1Password's op is stupid: it confounds trashed and non-trashed
            # items when trying to delete. Since we are forced to
            # create+delete in order to modify an item, we obviously become
            # stuck with a large set of identically-named items, making the
            # first delete fail unduly often. Fortunately, this first delete
            # shows us the UUIDs of colliding objects, so we can delete all of
            # them thereafter. Emptying the trash, either through the browser
            # or the desktop app, finally removes all these spurious dupes
            # from the database altogether.
            for uuid in $(jq --raw-input --raw-output 'match("op delete item ([0-9a-z]+)").captures[0].string' $p); do
                1p_op "delete item" "$uuid"
            done
        fi
    else
        echo "Missing name of item to remove."
        exit 20
    fi
}


function do_help()
{
    cat <<HELP
$0 -- A more usabel command line interface to 1Password


== Usages ==

1. $0
    - Lists all items over all accessible vaults.
2. $0 [-C|-E] [-j|-u|-p|-n|-U|-T] <title>[@<vault>]
    - Echoes / copies to clipboard data regarding an item. By default, this
      copies the password of the item to the clipboard.
3. $0 [-u|-p|-n|-U|-T] <title>[@<vault>] <new value>
    - Sets an attribute of an item, creating it if it does not exist.
4. $0 -e/--edit <title>[@<vault>]
    - Edits the notes associated to an item, creating it if it does not exist.
5. $0 -g [-N <reqs>] [-P <prefix>] [-S <suffix>] <title>[@<vault>]
    - Generates a random password for an item according to certain requirements.
6. $0 --rm <title>[@<vault>]
    - Deletes an item.
7. $0 -0/--logout
    - Logs out of 1Password, terminating the latest session.
8. $0 -h/--help
    - Prints this manual.


== Item specification ==

Forms 2 to 6 of the command specify an item of one's 1Password database for
query or modification. Such specification take the form

    <title>[@<vault>]

For instanace, if I want to query data about item \`Google' from vault
\`Common', I would specify it as

    Google@Common

Spaces in item and vault names are permitted, provided they are escaped or
quoted as the shell commands. If the vault is not specified, the user's
default vault is assumed (typically the Private vault).


== Initial setup ==

The first time this tool is used, a sequence of interactive queries will
grab one's main logon informations for 1Password, and save them for later
usage in file \$HOME/.1p. One may redo this setup by adding option --setup to
any form of the command.


== Logging in and logging out ==

1p is a wrapper around the \`op' utility developed by AgileBits. As such, it
leverages op's login mechanism, which requests the input of one's master
password to open a session. The result is a session token that 1p adds to
\$HOME/.1p to take avoid inputting one's password on every call of a sequence.
Given that this session token is saved in clear text in one's home directory,
it is prudent to log out as soon as one is done with using 1Password for a
while. One does so by invoking $0 with option --logout (shortened to -0).

The session is automatically terminated after 30 minutes of command line
inactivity.


== Description of options ==

-C / --copy       For data query (form 2), copies data to the clipboard
                  (ignored when -j/--json is set). This behaviour is the
                  default action for form 2.

-E / --echo       For data query (form 2), echoes data to standard output.

-N / --reqs       For password generation (form 5), specifies requirements
                  regarding the random password. Takes the following form:

                  -N <length>[:<n uppercase>[:<n digits>[:<n symbols>]]]

                  For instance, to require a password of length 32 with at
                  least 4 uppercase letters, at least 7 digits and at least
                  2 symbols, one would specify

                  --reqs=32:4:7:2

                  Default requirements are 16:1:1:1

                  Remark that the latter three requirements are not satisfied
                  to exactitude: a password requested with, say, 4 uppercase
                  letters, might end up having more. Only the password length
                  is satisfied exactly. Also, bear in mind that this program
                  has precious little patience with incoherent or insane
                  password requirements. Irk it at your own peril.

-P / --prefix     Sets a prefix for the randomly generated password (form 5).

-S / --suffix     Sets a suffix for the randomly generated password (form 5).

-T / --title      Queries or modifies the title of an item (forms 2 and 3).

-U / --url        Queries or modifies the URL associated to an item (form 2
                  and 3).

-e / --edit       Invokes one's favourite \$EDITOR to modify the notes
                  associated to an item (form 4). Once the user exits the
                  editor, the notes are saved back to the 1Password database.

-g / --generate   Generates a random password for the named item (form 5). If
                  the named item does not exist when the command is invoked,
                  it is created; otherwise, the password for the existing item
                  is modified.

-j / --json       For data queries (form 2), ignores field selection (options
                  -u/--username, -p/--password, -n/--notes, -T/--title and
                  -U/--url), and writes a JSON object with full data about the
                  object to standard output.

-n / --notes      Queries or modifies the notes associated to the named item
                  (forms 2 and 3).

-p / --password   Queries or modifies the password of the item (forms 2 and 3).
                  This is the default attribute affected by these forms of the
                  command.

--raw             Forces non-JSON formatting of data query results (form 2),
                  with attribute selection of the named item (through options
                  -u, -p, -n, -T or -U) and the possibility of clipboard copy.

--rm              Deletes ("trashes" in 1Password parlance) the named item
                  from the database (form 6).

--setup           Forces the initial setup sequence to be executed over, even
                  after it has been done successfully once.

-u / --user       Queries or modifies the username of the item (forms 2 and 3).

-0 / --logout     Terminates the current 1Password session, invalidating and
                  discarding the saved session token.


== Author ==

Benoit Hamelin <benoit@benoithamelin.com>
June 2018
HELP
}


function do_logout()
{
    1p_op "signout" >/dev/null 2>&1
    set_token_auth ""
    exit 0
}


#--- Entry point ------------------------------------------------------------

num_params=""
declare -a params
is_setup_initial=""
action="default"
format=""
item="password"
is_copy_or_echo="copy"
length=16
prefix=""
suffix=""

eval set -- $(getopt --name "$0" --options 'CEN:P:S:TUeghjnpu0' --longoptions 'copy,echo,title,url,edit,generate,reqs:,prefix:,suffix:,help,json,notes,password,raw,rm,setup,user,logout:' -- "$@") || exit $?
while [ -n "$1" ]; do
    case "$1" in
        -C | --copy)
            is_copy_or_echo="copy"
            ;;
        -E | --echo)
            is_copy_or_echo="echo"
            ;;
        -N | --reqs)
            reqs="$2"
            shift
            ;;
        -P | --prefix)
            prefix="$2"
            shift
            ;;
        -S | --suffix)
            suffix="$2"
            shift
            ;;
        -T | --title)
            item="title"
            ;;
        -U | --url)
            item="url"
            ;;
        -e | --edit)
            action="edit"
            ;;
        -g | --generate)
            action="generate"
            ;;
        -h | --help)
            action="help"
            ;;
        -j | --json)
            format="json"
            ;;
        -n | --notes)
            item="notes"
            ;;
        -p | --password)
            item="password"
            ;;
        --raw)
            format="raw"
            ;;
        --rm)
            action="rm"
            ;;
        --setup)
            is_setup_initial="yes"
            ;;
        -u | --user)
            item="username"
            ;;
        -0 | --logout)
            action="logout"
            ;;
        --)
            num_params=0
            ;;
        *)
            if [ -z "$num_params" ]; then
                echo "Unknown parameter: $1"
                echo "Check out documentation by invoking $0 --help."
                exit 1
            else
                params[$((num_params++))]=$(unquote "$1")
            fi
    esac
    shift
done

path_config="$HOME/.1p"
declare -a config
if [ ! -f "$path_config" -o -n "$is_setup_initial" ]; then
    setup_initial
else
    for name_config in domain email secret_key token_auth; do
        value=$(jq --raw-output ".$name_config" $path_config)
        eval "$name_config='$value'"
    done
fi

eval "do_$action"
exit $?
