#!/bin/bash


function unimplemented()
{
    echo "UNIMPLEMENTED"
    exit 127
}


function 1p_op()
{
    cmd="$1"
    shift
    op $cmd --session="$token_auth" "$@"
}


function setup_initial()
{
    echo "Hello! Before we start, I need a few parameters from you. You can look them up"
    echo "in the browser or desktop version of 1Password, typically somewhere around the"
    echo "Preferences dialog."
    echo
    read -p "Domain name: " domain && \
        read -p "E-mail address: " email && \
        read -p "Secret key: " secret_key
    cat > $path_config <<-CONFIG
	{
	    "domain": "$domain",
	    "email": "$email",
	    "secret_key": "$secret_key",
	    "token_auth": ""
	}
	CONFIG
    chmod 600 $path_config
    token_auth=""
    echo "Persistent configuration saved."
}


function set_token_auth()
{
    token_auth="$1"
    local p=$(mktemp)
    jq ".token_auth = \"$token_auth\"" $path_config >$p
    mv $p $path_config
}


function ensure_login()
{
    local msg_error=$(1p_op "get item" __dummy__ 2>&1)
    if grep --quiet 'not currently signed in\|Authentication required' <<<"$msg_error" && [ "$action" != "logout" ]; then
        local p=$(mktemp)
        op signin --output=raw $domain $email $secret_key >$p && \
            set_token_auth $(< $p)
        local x=$?
        rm -f $p
        [ "$x" -ne 0 ] && exit $x
    fi
}


function unquote()
{
    echo "$1" | xargs
}


function make_map_vaults()
{
    local p=$(mktemp)
    1p_op "list vaults" | jq --compact-output 'map({"key": .uuid, "value": .name}) | from_entries' >$p && \
        map_vaults=$(< $p)
    local x=$?
    rm -f $p
    [ "$x" -ne 0 ] && exit $x
}


function list_items()
{
    make_map_vaults
    local p=$(mktemp)
    1p_op "list items" | \
        jq --compact-output --argjson map_vaults "$map_vaults" \
            'map(
                {
                    "uuid"    : .uuid,
                    "vault"   : $map_vaults[.vaultUuid],
                    "name"    : .overview.title
                }
            )' >$p
    local x=$?
    local list_reformatted=$(<$p)
    rm -f $p
    [ "$x" -ne 0 ] && exit $x

    if [ "$format" = "json" ]; then
        jq '.' <<<"$list_reformatted"
    else
        local len_uuid=$(jq 'map(.uuid | length) | max' <<<"$list_reformatted")
        local len_vault=$(jq 'map(.vault | length) | max' <<<"$list_reformatted")
        jq --raw-output 'sort_by([.vault, .name]) | .[] | [.uuid, .vault, .name] | join("::")' <<<"$list_reformatted" | \
            awk -F '::' "\
                BEGIN{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \"UUID\", \"VAULT\", \"NAME\") } \
                1{ printf(\"%-${len_uuid}s   %-${len_vault}s   %s\\n\", \$1, \$2, \$3) }"
    fi
}


function build_opt_vault()
{
    local opt_vault=""
    if [ -n "$vault" ]; then
        opt_vault="--vault=$vault"
    fi
}


function get_item_from_1p()
{
    build_opt_vault
    local p=$(mktemp)
    trap "rm -f $p" EXIT
    1p_op "get item" "$title" $opt_vault >$p
    x=$?
    if [ $x -eq 0 ]; then
        jq --compact-output --argjson map_vaults "$map_vaults" '
            def field_value(name_field): ((.details.fields // [])[] | select(.name == name_field) | .value) // "" ;
            {
                "uuid":        .uuid,
                "username":    field_value("username"),
                "password":    field_value("password"),
                "notes":       (.details.notesPlain // ""),
                "title":       (.overview.title // ""),
                "url":         (.overview.url // ""),
                "vault":       ($map_vaults[.vaultUuid] // .vaultUuid),
                "details_raw": .details
            }' <$p
    else
        return $x
    fi
}


function get_item_from_1p_or_create()
{
    if ! get_item_from_1p 2>/dev/null; then
        cat <<-SKELETON
		{
		    "uuid":        "",
		    "username":    "",
		    "password":    "",
		    "notes":       "",
		    "title":       "$title",
		    "url":         "",
		    "vault":       "$vault",
		    "details_raw": $(1p_op "get template" Login)
		}
		SKELETON
    fi
}


function get_item()
{
    make_map_vaults
    get_item_from_1p | \
        (
            if [ "$format" = "json" ]; then
                jq 'del(.details_raw)'
            else
                jq --raw-output --arg item "$item" '.[$item]' | (
                    if [ "$is_copy_or_echo" = "echo" ]; then
                        cat
                    else
                        tr -d "\n" | xsel -ib
                    fi
                )
            fi
        ) || exit $?
}


function modify_item()
{
    build_opt_vault
    if 1p_op "create item" Login $(echo "$details" | op encode) --title="$title" --url="$url" $opt_vault >/dev/null; then
        if [ -n "$uuid_orig" ]; then
            1p_op "delete item" "$uuid_orig"
        fi
    fi
}


function set_item()
{
    map_vaults='{}'
    local p=$(mktemp)
    get_item_from_1p_or_create >$p || exit $?
    trap "rm -f $p" EXIT
    local item_raw=$(cat $p && rm $p)
    uuid_orig=$(jq --raw-output '.uuid' <<<"$item_raw")
    url=$(jq --raw-output '.url' <<<"$item_raw")
    title=$(jq --raw-output '.title' <<<"$item_raw")
    vault=$(jq --raw-output '.vault' <<<"$item_raw")
    details=$(jq --raw-output '.details_raw' <<<"$item_raw")

    local new_value="${params[1]}"
    case "$item" in
        password | username)
            details=$(jq --arg attr "$item" --arg new_value "$new_value" \
                --argjson map_type '{"username": "T", "password": "P"}' \
                '.fields = ([.fields[] | select(.name != $attr)] + [{"name": $attr, "designation": $attr, "type": $map_type[$attr], "value": $new_value}])' \
                <<<"$details")
            ;;
        notes)
            details=$(jq --arg new_value "$new_value" '.notesPlain = $new_value' <<<"$details")
            ;;
        url | title)
            eval "$item=\"$new_value\""
            ;;
        *)
            echo "Don't know how to set attribute \`$item'."
            exit 10
            ;;
    esac

    modify_item
}


function split_title_vault()
{
    if [ -n "${params[0]}" ]; then
        eval $(jq --raw-input --raw-output 'split("@") | "title=\"\(.[0])\"\nvault=\"\(.[1] // "")\"\n"' <<<"${params[0]}")
    else
        title=""
        vault=""
    fi
}


function do_default()
{
    split_title_vault
    ensure_login

    case "$num_params" in
        0) list_items ;;
        1) get_item   ;;
        *) set_item   ;;
    esac
}


function do_edit()
{
    ensure_login
    split_title_vault
    map_vaults='{}'
    if [ -n "title" ]; then
        if [ -z "$EDITOR" ]; then
            EDITOR="vi"
        fi

        local p=$(mktemp)
        trap "rm -f $p $p.raw" EXIT
        get_item_from_1p_or_create >"$p.raw" || exit $?
        jq --raw-output '.notes' "$p.raw" >"$p"
        eval "$EDITOR $p" || exit $?

        if ! diff -q $p <(jq --raw-output '.notes' "$p.raw") 2>/dev/null; then
            uuid_orig=$(jq --raw-output '.uuid' "$p.raw")
            url=$(jq --raw-output '.url' "$p.raw")
            vault=$(jq --raw-output '.vault' "$p.raw")
            details=$(jq --raw-output --arg notes "$(cat "$p")" '.details_raw | .notesPlain = $notes' "$p.raw")
            modify_item
        fi
    else
        echo "Missing name of item to edit notes for."
        exit 20
    fi
}


function count_chars()
{
    tr -d "\n" <<<"$1" | jq --raw-input "explode | map(select($2)) | implode | length"
}


function count_uppers()
{
    count_chars "$1" '. >= 64 and . <= 90'
}


function count_digits()
{
    count_chars "$1" '. >= 48 and . <= 57'
}


function count_symbols()
{
    count_chars "$1" '[.] | inside("_-+=!@#$%&*()[]{}\\|;:,.<>/?~" | explode)'
}


function string_length()
{
    jq --raw-input 'length' <<<"$1"
}


function do_generate()
{
    if [ -z "${params[0]}" ]; then
        echo "Specify the name of the item for which to generate a random password."
        exit 41
    fi

    eval $(
        jq --raw-output 'split(":") | map(try tonumber catch null) |
            "length_total=\(.[0] // 16); num_uppers=\(.[1] // 1); num_digits=\(.[2] // 1); num_symbols=\(.[3] // 1)"' \
            <<<"\"$reqs\""
    ) || exit $?
    local max_length=40
    local min_length=8
    local min_all_lower=16
    if [ "$length_total" -gt "$max_length" ]; then
        cat 2>/dev/null <<TOOLONG
$length_total characters? Take a chill pill, buddy, and stick to $max_length or
less. You know you might have to *type* this password sometimes, yes?
Seriously. I'm setting you back at $max_length characters.
TOOLONG
        length_total=$max_length
    elif [ $length_total -lt 8 ]; then
        cat 2>/dev/null <<TOOSHORT
$length_total characters. Come on, buddy. This is a computer, and this is the
goddamn 21st century. In the overwhelming majority of cases, you will merely
have to copy-paste this damn password. Geez, you people. I'm setting you up to
$min_length characters, and I don't care whether you like it.
TOOSHORT
        length_total=$min_length
    fi
    if [ $num_uppers -lt 1 -a $num_digits -lt 1 -a $num_symbols -lt 1 -a $length_total -lt 16 ]; then
        cat 2>/dev/null <<JUSTBAD
You know, I've seen the XKCD cartoon and I know of the common password best
practices, but you're taking this too far. Either you go long, or you go
complex. I think that complex sucks, so I'm rising your password length to
$min_all_lower characters. Don't thank me, I'm just a machine.
JUSTBAD
        length_total=$min_all_lower
    fi

    if [ $num_uppers -lt 0 ]; then
        num_uppers=0
    fi
    if [ $num_digits -lt 0 ]; then
        num_digits=0
    fi
    if [ $num_symbols -lt 0 ]; then
        num_symbols=0
    fi

    local presuf="$prefix$suffix"
    local length_middle=$(( $length_total - $(string_length "$presuf") ))
    if [ $length_middle -le 0 ]; then
        if [ $(count_uppers "$presuf") -lt $num_uppers -o \
            $(count_digits "$presuf") -lt $num_digits -o \
            $(count_symbols "$presuf") -lt $num_symbols ]
        then
            cat 2>/dev/null <<INCOHERENT
Your prefix and suffix make up a password at least as long as you wish for,
but without all the uppercase letters, digits or symbols you demand.  Get your
act together and try again, buddy.
INCOHERENT
            exit 42
        else
            cat 2>/dev/null <<PRESUF
Warning: the provided prefix and suffix suffice to satisfy all the constraints
set on the final password, so it will bear no randomly generated component.
PRESUF
            password="$presuf"
        fi
    else
        while true; do
            local middle=$(head -c $length_middle /dev/urandom | \
                tr '\000-\377' 'a-za-za-za-zA-ZA-ZA-Z0-90-90-9_+=!@#$%&*()[]{}|;:,.<>?~_+=!@#$%&*()[]{}|')
            password="$prefix$middle$suffix"
            if [ $(count_uppers "$password") -ge $num_uppers -a \
                $(count_digits "$password") -ge $num_digits -a \
                $(count_symbols "$password") -ge $num_symbols ]
            then
                break
            fi
        done
    fi

    echo "-- $password --" && exit 0
    exec $0 --password "${params[0]}" "$password"
}


function do_rm()
{
    ensure_login
    split_title_vault
    if [ -n "$title" ]; then
        build_opt_vault
        local p=$(mktemp)
        trap "rm -f $p" EXIT
        if ! 1p_op "delete item" "$title" $opt_vault 2>$p; then
            # 1Password's op is stupid: it confounds trashed and non-trashed
            # items when trying to delete. Since we are forced to
            # create+delete in order to modify an item, we obviously become
            # stuck with a large set of identically-named items, making the
            # first delete fail unduly often. Fortunately, this first delete
            # shows us the UUIDs of colliding objects, so we can delete all of
            # them thereafter. Emptying the trash, either through the browser
            # or the desktop app, finally removes all these spurious dupes
            # from the database altogether.
            for uuid in $(jq --raw-input --raw-output 'match("op delete item ([0-9a-z]+)").captures[0].string' $p); do
                1p_op "delete item" "$uuid"
            done
        fi
    else
        echo "Missing name of item to remove."
        exit 20
    fi
}


function do_logout()
{
    1p_op "signout" >/dev/null 2>&1
    set_token_auth ""
    exit 0
}


num_params=""
declare -a params
is_setup_initial=""
action="default"
format=""
item="password"
is_copy_or_echo="copy"
length=16
prefix=""
suffix=""

eval set -- $(getopt --name "$0" --options 'CEN:P:S:TUeghjnpu0' --longoptions 'copy,echo,title,url,edit,generate,reqs:,prefix:,suffix:,help,json,notes,password,raw,rm,setup,user,logout:' -- "$@") || exit $?
while [ -n "$1" ]; do
    case "$1" in
        -C | --copy)
            is_copy_or_echo="copy"
            ;;
        -E | --echo)
            is_copy_or_echo="echo"
            ;;
        -N | --reqs)
            reqs="$2"
            shift
            ;;
        -P | --prefix)
            prefix="$2"
            shift
            ;;
        -S | --suffix)
            suffix="$2"
            shift
            ;;
        -T | --title)
            item="title"
            ;;
        -U | --url)
            item="url"
            ;;
        -e | --edit)
            action="edit"
            ;;
        -g | --generate)
            action="generate"
            ;;
        -j | --json)
            format="json"
            ;;
        -n | --notes)
            item="notes"
            ;;
        -p | --password)
            item="password"
            ;;
        --raw)
            format="raw"
            ;;
        --rm)
            action="rm"
            ;;
        --setup)
            is_setup_initial="yes"
            ;;
        -u | --user)
            item="username"
            ;;
        -0 | --logout)
            action="logout"
            ;;
        --)
            num_params=0
            ;;
        *)
            if [ -z "$num_params" ]; then
                echo "Unknown parameter: $1"
                echo "Check out documentation by invoking $0 --help."
                exit 1
            else
                params[$((num_params++))]=$(unquote "$1")
            fi
    esac
    shift
done

path_config="$HOME/.1p"
declare -a config
if [ ! -f "$path_config" -o -n "$is_setup_initial" ]; then
    setup_initial
else
    for name_config in domain email secret_key token_auth; do
        value=$(jq --raw-output ".$name_config" $path_config)
        eval "$name_config='$value'"
    done
fi

eval "do_$action"
exit $?
